<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <title>QCX v3.1 SS ‚Äì Universal Encrypted Archive (Single HTML)</title>
  <!-- Library kompresi (zlib/DEFLATE) -->
  <script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.min.js"></script>
  <!-- Argon2id untuk KDF memory-hard -->
  <script src="https://cdn.jsdelivr.net/npm/argon2-browser/dist/argon2-bundled.min.js"></script>
  <style>
    :root {
      --bg: #050509;
      --panel: #0b0b15;
      --panel-soft: #10101a;
      --border: #1f2937;
      --accent: #2563eb;
      --accent-soft: #1d4ed8;
      --accent-warn: #f97316;
      --text-main: #f9fafb;
      --text-dim: #9ca3af;
      --btn-sec: #4b5563;
      --btn-sec-hover: #6b7280;
      --radius: 14px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 24px 12px 40px;
      background: radial-gradient(circle at top, #111827 0, #010108 45%, #000 100%);
      color: var(--text-main);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    .app { max-width: 1160px; margin: 0 auto; }

    h1 {
      margin: 0 0 4px;
      font-size: clamp(1.8rem, 3vw, 2.4rem);
    }

    .subtitle {
      margin: 0 0 12px;
      color: var(--text-dim);
      font-size: 0.95rem;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.7rem;
      background: rgba(37,99,235,0.12);
      border: 1px solid rgba(37,99,235,0.5);
      margin-bottom: 10px;
    }

    .badge-kdf {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.76rem;
      background: rgba(15,118,110,0.25);
      border: 1px solid #0f766e;
      margin-bottom: 18px;
    }

    .grid {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
    }

    .panel {
      flex: 1 1 320px;
      min-width: 0;
      background: linear-gradient(135deg, #0b0b15, #050510);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px 16px 18px;
      box-shadow: 0 18px 40px rgba(0,0,0,0.5);
    }

    .panel h2 {
      margin: 0 0 4px;
      font-size: 1.1rem;
    }

    .panel small {
      color: var(--text-dim);
      font-size: 0.8rem;
    }

    .field-label {
      display: block;
      margin-top: 12px;
      font-size: 0.85rem;
      color: var(--text-dim);
    }

    input[type="file"] {
      margin-top: 8px;
      font-size: 0.85rem;
      color: var(--text-main);
    }

    input[type="password"] {
      width: 100%;
      margin-top: 4px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--panel-soft);
      color: var(--text-main);
      font-size: 0.9rem;
      outline: none;
    }

    input[type="password"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(37,99,235,0.35);
    }

    .btn-row {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    button {
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.12s ease, transform 0.08s ease, box-shadow 0.12s ease;
      white-space: nowrap;
    }

    .btn-main {
      background: var(--accent);
      color: #fff;
      box-shadow: 0 6px 16px rgba(37,99,235,0.45);
    }
    .btn-main:hover {
      background: var(--accent-soft);
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(37,99,235,0.6);
    }

    .btn-sec {
      background: var(--btn-sec);
      color: var(--text-main);
    }
    .btn-sec:hover {
      background: var(--btn-sec-hover);
      transform: translateY(-1px);
    }

    .btn-warn {
      background: var(--accent-warn);
      color: #111827;
    }
    .btn-warn:hover {
      background: #fb923c;
      transform: translateY(-1px);
    }

    #log, #logMulti, #selfTestLog {
      margin-top: 10px;
      padding: 10px;
      background: var(--panel-soft);
      border-radius: 10px;
      min-height: 64px;
      font-size: 0.78rem;
      white-space: pre-line;
      color: var(--text-dim);
    }

    .table-wrap {
      margin-top: 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      max-height: 320px;
      overflow-y: auto;
      overflow-x: hidden;
      display: none;
      background: #020617;
    }

    .table-wrap::-webkit-scrollbar { width: 8px; }
    .table-wrap::-webkit-scrollbar-thumb {
      background: #374151;
      border-radius: 4px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.78rem;
    }
    th, td {
      padding: 6px 8px;
      border-bottom: 1px solid #111827;
      text-align: left;
    }
    th {
      background: #0f172a;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .cell-path {
      max-width: 240px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .progress-row {
      margin-top: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.75rem;
      color: var(--text-dim);
    }
    .progress-bar-wrap {
      flex: 1;
      background: #020617;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid #111827;
      height: 6px;
    }
    .progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #2563eb, #a855f7);
      transition: width 0.08s linear;
    }

    details {
      margin-top: 14px;
      background: #020617;
      border-radius: 10px;
      border: 1px solid #1f2937;
      padding: 8px 10px;
      font-size: 0.8rem;
      color: var(--text-dim);
    }
    details summary {
      cursor: pointer;
      color: var(--text-main);
    }

    code, pre {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.78rem;
    }

    @media (max-width: 768px) {
      body { padding: 18px 10px 32px; }
      .panel { padding: 13px 13px 15px; }
      .cell-path { max-width: 160px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>QCX v4 ‚Äì Universal Encrypted Archive</h1>
    <p class="subtitle">
      Format arsip terenkripsi client-side satu file HTML. Single & multi file ‚Üí satu <code>.qcx</code> dengan kemampuan tinggi
    </p>

    <div class="badge">
      ‚ö° Created By Gede Dylan Pratama Wijaya
    </div>

    <div class="badge-kdf">
      üîê KDF:
      <label style="display:inline-flex;align-items:center;gap:4px;margin-left:8px;font-weight:500;">
        <input type="radio" name="kdfMode" value="pbkdf2" checked> PBKDF2 (400k iter)
      </label>
      <label style="display:inline-flex;align-items:center;gap:4px;margin-left:8px;font-weight:500;">
        <input type="radio" name="kdfMode" value="argon2id"> Argon2id (~64MB √ó 3)
      </label>
      <span id="kdfModeInfo" style="margin-left:auto;opacity:0.8;">
        Mode aktif: PBKDF2
      </span>
    </div>

    <details>
      <summary>üìò QCX v3.1 ‚Äì SPEC singkat di dalam HTML ini</summary>
      <pre id="specText"></pre>
    </details>

    <details>
      <summary>üß™ Self-test & fuzz status (internal QCX tester)</summary>
      <div id="selfTestLog">Menunggu self-test...</div>
      <button class="btn-sec" id="btnRunSelfTest" style="margin-top:8px;">Jalankan Self-Test & Fuzz Lagi</button>
    </details>

    <div class="grid" style="margin-top:16px;">
      <!-- PANEL KIRI: SINGLE FILE -->
      <div class="panel">
        <h2>Mode Single File (Streaming-friendly)</h2>
        <small>
          Kompres satu file apa pun (DOCX, PDF, ZIP, video, dll) menjadi satu QCX terenkripsi,
          atau ekstrak kembali file dari QCX. Pembacaan file bertahap (chunk) dengan progress.
        </small>

        <label class="field-label">Pilih file (file biasa untuk kompres, atau .qcx untuk ekstrak):</label>
        <input type="file" id="singleInput">

        <label class="field-label">Password arsip (minimal 6 karakter):</label>
        <input type="password" id="singlePassword" placeholder="Password untuk QCX">

        <div class="btn-row">
          <button class="btn-main" id="btnSingleCompress">Kompres ‚Üí .qcx</button>
          <button class="btn-sec" id="btnSingleDecompress">Ekstrak dari .qcx</button>
        </div>

        <div class="progress-row">
          <span id="singleProgressText">Idle</span>
          <div class="progress-bar-wrap">
            <div class="progress-bar" id="singleProgressBar"></div>
          </div>
        </div>

        <div id="log">Log single akan muncul di sini‚Ä¶</div>
      </div>

      <!-- PANEL KANAN: MULTI FILE / FOLDER -->
      <div class="panel">
        <h2>Mode Multi File / Folder</h2>
        <small>
          Kompres banyak file / seluruh folder menjadi satu QCX (dedup & kompres global),
          bisa dilihat isinya dan diekstrak per-file atau semua sekaligus.
        </small>

        <label class="field-label">Pilih banyak file / folder:</label>
        <input type="file" id="multiInput" multiple webkitdirectory>

        <label class="field-label">Password untuk QCX baru:</label>
        <input type="password" id="multiPassword" placeholder="Minimal 6 karakter">

        <div class="btn-row">
          <button class="btn-main" id="btnCreateMulti">Buat QCX Multi</button>
        </div>

        <hr style="border:none;border-top:1px solid var(--border);margin:14px 0;">

        <label class="field-label">Buka QCX yang sudah ada:</label>
        <input type="file" id="qcxOpenInput" accept=".qcx">

        <label class="field-label">Password QCX yang akan dibuka:</label>
        <input type="password" id="openPassword" placeholder="Password arsip">

        <div class="btn-row">
          <button class="btn-sec" id="btnOpenQcx">Buka & Lihat Isi</button>
          <button class="btn-warn" id="btnExtractAll">Ekstrak Semua ‚Üí Download</button>
        </div>

        <div id="logMulti">Log multi akan muncul di sini‚Ä¶</div>

        <div class="table-wrap" id="tableWrap">
          <table>
            <thead>
            <tr>
              <th>Path</th>
              <th>Ukuran</th>
              <th>CRC32</th>
              <th>Aksi</th>
            </tr>
            </thead>
            <tbody id="tableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

<script>
/* ===================== QCX v3.1 SPEC TEXT ===================== */
const QCX_SPEC_TEXT = `
FORMAT QCX v3.1 (ringkasan)

- File layout (little-endian):
  [4 byte] outerHeaderLen (uint32 LE)
  [N byte] outerHeaderJson (UTF-8)
  [M byte] ciphertext (AES-GCM payload)

- outerHeaderJson (tidak terenkripsi, meta & param kripto):
  {
    "magic": "QCX3",
    "version": 3,
    "kdf": {
      "algo": "PBKDF2" atau "Argon2id",
      "hash": "SHA-256" atau "BLAKE2b",
      "iter": <int>,        // PBKDF2: iterasi; Argon2: time cost
      "saltHex": "...",     // 16 byte random
      "memKB": <int?>,      // untuk Argon2
      "parallelism": <int?> // untuk Argon2
    },
    "cipher": {
      "algo": "AES-GCM",
      "keyBits": 256,
      "ivHex": "..." // 12 byte random
    },
    "meta": {
      "fileCount": <int>,
      "totalSize": <int>,
      "uniqueSize": <int>,
      "createdAt": <unix_ms>,
      "note": "QCX v3.1 universal encrypted archive"
    }
  }

- ciphertext = AES-GCM-256(key, iv, compressedInnerPayload)

- key:
  - PBKDF2: key = PBKDF2(password_utf8, salt, iter, SHA-256, 32 byte)
  - Argon2id: key = Argon2id(password_utf8, salt, time=iter, memKB, parallelism).hash(32B)

- compressedInnerPayload = zlib(innerRaw)

- innerRaw:
  [4 byte] innerHeaderLen (uint32 LE)
  [A byte] innerHeaderJson (UTF-8)
  [B byte] dataConcat (gabungan data unik)

- innerHeaderJson:
  {
    "fileCount": <int>,
    "totalSize": <int>,
    "uniqueSize": <int>,
    "createdAt": <unix_ms>,
    "files": [
      {
        "path": "subdir/file.txt",
        "size": <int>,
        "offset": <int>,
        "length": <int>,
        "mime": "application/octet-stream",
        "crc32": "xxxxxxxx"
      }, ...
    ]
  }

- dataConcat: satu buffer besar berisi data unik semua file.
  File dengan isi identik (size + CRC32 + isi sama) share offset yang sama (dedup).
`;

/* ====== PARAMETER KEAMANAN GLOBAL ====== */
const QCX_PBKDF2_ITER = 400000; // PBKDF2 iterasi default (berat)
const QCX_ARGON2_DEFAULT = {
  memKB: 64 * 1024, // 64MB
  time: 3,
  parallelism: 1,
  hashLen: 32
};

// mode aktif (bisa diganti via radio button di UI)
let currentKdfMode = "pbkdf2"; // atau "argon2id"

const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();

/* ===================== UTIL ===================== */
function crc32(buf) {
  let table = crc32.table;
  if (!table) {
    table = crc32.table = new Uint32Array(256);
    for (let i = 0; i < 256; i++) {
      let c = i;
      for (let k = 0; k < 8; k++) {
        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
      }
      table[i] = c >>> 0;
    }
  }
  let crc = 0 ^ (-1);
  for (let i = 0; i < buf.length; i++) {
    crc = (crc >>> 8) ^ table[(crc ^ buf[i]) & 0xff];
  }
  return (crc ^ (-1)) >>> 0;
}

function toHex(u8) {
  return Array.from(u8).map(b => b.toString(16).padStart(2, "0")).join("");
}
function fromHex(str) {
  if (str.length % 2 !== 0) throw new Error("Invalid hex length");
  const out = new Uint8Array(str.length / 2);
  for (let i = 0; i < str.length; i += 2) {
    out[i / 2] = parseInt(str.slice(i, i + 2), 16);
  }
  return out;
}

/* ========== PBKDF2 + Argon2 + AES-GCM ========== */
async function deriveKeyPBKDF2(password, salt, iterations = QCX_PBKDF2_ITER) {
  const pwBytes = textEncoder.encode(password);
  const baseKey = await crypto.subtle.importKey("raw", pwBytes, "PBKDF2", false, ["deriveKey"]);
  return await crypto.subtle.deriveKey(
    { name: "PBKDF2", salt, iterations, hash: "SHA-256" },
    baseKey,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
}

// Argon2id via argon2-browser
async function deriveKeyArgon2(password, salt, params) {
  if (typeof argon2 === "undefined") {
    throw new Error("Argon2 library tidak tersedia");
  }
  const pw = typeof password === "string" ? password : textDecoder.decode(password);
  const saltHex = toHex(salt);
  const hash = await argon2.hash({
    pass: pw,
    salt: saltHex,
    time: params.time,
    mem: params.memKB,
    hashLen: params.hashLen,
    parallelism: params.parallelism,
    type: argon2.ArgonType.Argon2id
  });
  const keyBytes = hash.hash; // Uint8Array 32B
  return await crypto.subtle.importKey(
    "raw",
    keyBytes,
    { name: "AES-GCM" },
    false,
    ["encrypt", "decrypt"]
  );
}

// Untuk pembuatan arsip baru (mengikuti currentKdfMode)
async function deriveKeyForCreate(password, salt, iterations) {
  if (currentKdfMode === "argon2id") {
    return await deriveKeyArgon2(password, salt, QCX_ARGON2_DEFAULT);
  } else {
    return await deriveKeyPBKDF2(password, salt, iterations);
  }
}

// Untuk membuka arsip (mengikuti info di header)
async function deriveKeyForOpen(password, salt, kdfInfo) {
  if (kdfInfo.algo === "Argon2id") {
    const params = {
      memKB: kdfInfo.memKB || QCX_ARGON2_DEFAULT.memKB,
      time: kdfInfo.iter || QCX_ARGON2_DEFAULT.time,
      parallelism: kdfInfo.parallelism || QCX_ARGON2_DEFAULT.parallelism,
      hashLen: QCX_ARGON2_DEFAULT.hashLen
    };
    return await deriveKeyArgon2(password, salt, params);
  } else {
    const iter = kdfInfo.iter || QCX_PBKDF2_ITER;
    return await deriveKeyPBKDF2(password, salt, iter);
  }
}

async function aesGcmEncrypt(key, iv, plaintext) {
  const ct = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, plaintext);
  return new Uint8Array(ct);
}
async function aesGcmDecrypt(key, iv, ciphertext) {
  const pt = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ciphertext);
  return new Uint8Array(pt);
}

/* ========== CORE: CREATE ARCHIVE (from buffers) ========== */
async function qcxCreateArchiveFromBuffers(fileEntries, password, options = {}) {
  if (!fileEntries || fileEntries.length === 0) {
    throw new Error("Tidak ada file untuk diarsip.");
  }
  if (typeof password !== "string" || password.length < 6) {
    throw new Error("Password minimal 6 karakter.");
  }
  const iterPBKDF2 = options.iterations || QCX_PBKDF2_ITER;
  const logFn = options.logFn || (() => {});

  const fileObjs = [];
  let totalSize = 0;

  for (const ent of fileEntries) {
    const path = ent.path || ent.name;
    const mime = ent.type || "application/octet-stream";
    const buf = ent.data;
    const size = buf.length;
    const c = crc32(buf);
    totalSize += size;
    fileObjs.push({ path, mime, buf, size, crc: c });
    logFn(`+ ${path} (${size} B)`);
  }

  logFn("Dedup file (berdasarkan size+CRC32+isi)...");
  const uniqueMap = new Map(); // key -> {buf, offset}
  const filesMeta = [];
  let uniqueTotalSize = 0;

  for (const fo of fileObjs) {
    const keyBase = fo.size + "_" + fo.crc.toString(16);
    let entry = uniqueMap.get(keyBase);
    if (entry) {
      const ubuf = entry.buf;
      if (ubuf.length === fo.buf.length) {
        let same = true;
        for (let i = 0; i < ubuf.length; i++) {
          if (ubuf[i] !== fo.buf[i]) { same = false; break; }
        }
        if (same) {
          filesMeta.push({
            path: fo.path,
            offset: entry.offset,
            length: fo.size,
            size: fo.size,
            mime: fo.mime,
            crc32: fo.crc.toString(16)
          });
          continue;
        }
      }
    }
    // unik
    entry = { buf: fo.buf, offset: uniqueTotalSize };
    uniqueMap.set(keyBase, entry);
    filesMeta.push({
      path: fo.path,
      offset: entry.offset,
      length: fo.size,
      size: fo.size,
      mime: fo.mime,
      crc32: fo.crc.toString(16)
    });
    uniqueTotalSize += fo.size;
  }

  logFn(`Total asli: ${totalSize} B`);
  logFn(`Ukuran unik setelah dedup: ${uniqueTotalSize} B`);

  const dataConcat = new Uint8Array(uniqueTotalSize);
  for (const entry of uniqueMap.values()) {
    dataConcat.set(entry.buf, entry.offset);
  }

  const innerHeader = {
    fileCount: filesMeta.length,
    totalSize,
    uniqueSize: uniqueTotalSize,
    createdAt: Date.now(),
    files: filesMeta
  };
  const innerHeaderBytes = textEncoder.encode(JSON.stringify(innerHeader));
  const innerHeaderLen = innerHeaderBytes.length;

  const innerRaw = new Uint8Array(4 + innerHeaderLen + dataConcat.length);
  const dvInner = new DataView(innerRaw.buffer);
  dvInner.setUint32(0, innerHeaderLen, true);
  innerRaw.set(innerHeaderBytes, 4);
  innerRaw.set(dataConcat, 4 + innerHeaderLen);

  logFn("Kompresi payload internal (zlib/DEFLATE)...");
  const compressed = fflate.zlibSync(innerRaw, { level: 9 });

  logFn("Derivasi key (PBKDF2/Argon2)...");
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const key = await deriveKeyForCreate(password, salt, iterPBKDF2);

  logFn("Enkripsi AES-GCM-256...");
  const ciphertext = await aesGcmEncrypt(key, iv, compressed);

  const kdfInfo =
    currentKdfMode === "argon2id"
      ? {
          algo: "Argon2id",
          hash: "BLAKE2b",
          iter: QCX_ARGON2_DEFAULT.time,
          memKB: QCX_ARGON2_DEFAULT.memKB,
          parallelism: QCX_ARGON2_DEFAULT.parallelism
        }
      : {
          algo: "PBKDF2",
          hash: "SHA-256",
          iter: iterPBKDF2
        };

  const outerHeader = {
    magic: "QCX3",
    version: 3,
    kdf: kdfInfo,
    cipher: {
      algo: "AES-GCM",
      keyBits: 256,
      ivHex: toHex(iv)
    },
    meta: {
      fileCount: innerHeader.fileCount,
      totalSize: innerHeader.totalSize,
      uniqueSize: innerHeader.uniqueSize,
      createdAt: innerHeader.createdAt,
      note: "QCX v3.1 universal encrypted archive"
    },
    saltHex: toHex(salt) // disimpan di top-level agar kompatibel
  };

  const outerHeaderBytes = textEncoder.encode(JSON.stringify(outerHeader));
  const outerHeaderLen = outerHeaderBytes.length;

  const out = new Uint8Array(4 + outerHeaderLen + ciphertext.length);
  const dvOuter = new DataView(out.buffer);
  dvOuter.setUint32(0, outerHeaderLen, true);
  out.set(outerHeaderBytes, 4);
  out.set(ciphertext, 4 + outerHeaderLen);

  logFn("QCX selesai dibuat.");
  return { qcxBytes: out, innerHeader };
}

/* ========== CORE: OPEN ARCHIVE ========== */
async function qcxOpenArchive(bufInput, password) {
  if (typeof password !== "string" || !password.length) {
    throw new Error("Password QCX wajib diisi.");
  }
  const buf = bufInput instanceof Uint8Array ? bufInput : new Uint8Array(bufInput);
  if (buf.length < 8) throw new Error("File terlalu kecil, bukan QCX valid.");

  const dv = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
  const outerHeaderLen = dv.getUint32(0, true);
  if (outerHeaderLen <= 0 || outerHeaderLen > buf.length - 4) {
    throw new Error("Outer header length tidak valid.");
  }

  const outerHeaderBytes = buf.slice(4, 4 + outerHeaderLen);
  const outerHeaderText = textDecoder.decode(outerHeaderBytes);
  let outerHeader;
  try {
    outerHeader = JSON.parse(outerHeaderText);
  } catch {
    throw new Error("Outer header corrupt (JSON gagal dibaca).");
  }

  if (outerHeader.magic !== "QCX3" || outerHeader.version !== 3) {
    throw new Error("Magic/versi tidak cocok, bukan QCX3.");
  }

  const ciphertext = buf.slice(4 + outerHeaderLen);
  if (!ciphertext.length) throw new Error("Payload ciphertext kosong.");

  // kompatibel dengan layout: saltHex bisa di outerHeader.saltHex atau outerHeader.kdf.saltHex
  const saltHex = outerHeader.saltHex || (outerHeader.kdf && outerHeader.kdf.saltHex);
  if (!saltHex) {
    throw new Error("Salt tidak ditemukan di header.");
  }
  const salt = fromHex(saltHex);
  const iv = fromHex(outerHeader.cipher.ivHex);
  const kdfInfo = outerHeader.kdf || {
    algo: "PBKDF2",
    hash: "SHA-256",
    iter: QCX_PBKDF2_ITER
  };

  const key = await deriveKeyForOpen(password, salt, kdfInfo);

  let compressed;
  try {
    compressed = await aesGcmDecrypt(key, iv, ciphertext);
  } catch {
    throw new Error("Dekripsi gagal (password salah atau data rusak).");
  }

  let innerRaw;
  try {
    innerRaw = fflate.unzlibSync(compressed);
  } catch {
    throw new Error("Gagal membuka kompresi (inner payload rusak).");
  }

  if (innerRaw.length < 4) throw new Error("Inner payload terlalu kecil.");
  const dvInner = new DataView(innerRaw.buffer, innerRaw.byteOffset, innerRaw.byteLength);
  const innerHeaderLen = dvInner.getUint32(0, true);
  if (innerHeaderLen <= 0 || innerHeaderLen > innerRaw.length - 4) {
    throw new Error("Inner header length tidak valid.");
  }

  const innerHeaderBytes = innerRaw.slice(4, 4 + innerHeaderLen);
  const innerHeaderText = textDecoder.decode(innerHeaderBytes);
  let innerHeader;
  try {
    innerHeader = JSON.parse(innerHeaderText);
  } catch {
    throw new Error("Inner header corrupt (JSON gagal dibaca).");
  }

  const dataConcat = innerRaw.slice(4 + innerHeaderLen);

  function getFileSlice(index) {
    const files = innerHeader.files || [];
    if (index < 0 || index >= files.length) {
      throw new Error("Index file di luar jangkauan.");
    }
    const f = files[index];
    return dataConcat.slice(f.offset, f.offset + f.length);
  }

  function getFileByPath(path) {
    const files = innerHeader.files || [];
    const f = files.find(x => x.path === path);
    if (!f) return null;
    return dataConcat.slice(f.offset, f.offset + f.length);
  }

  return { outerHeader, innerHeader, dataConcat, getFileSlice, getFileByPath };
}

/* ========== STREAMING SINGLE FILE HELPER ========== */
function updateCrc32Streaming(prevCrc, buf) {
  let table = crc32.table;
  if (!table) {
    table = crc32.table = new Uint32Array(256);
    for (let i = 0; i < 256; i++) {
      let c = i;
      for (let k = 0; k < 8; k++) {
        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
      }
      table[i] = c >>> 0;
    }
  }
  let crc = prevCrc;
  for (let i = 0; i < buf.length; i++) {
    crc = (crc >>> 8) ^ table[(crc ^ buf[i]) & 0xff];
  }
  return crc;
}
async function readFileAsUint8ArrayStreaming(file, opts = {}) {
  const chunkSize = opts.chunkSize || 8 * 1024 * 1024;
  const onProgress = opts.onProgress || (() => {});
  const total = file.size;
  const out = new Uint8Array(total);
  let offset = 0;
  let crc = 0 ^ (-1);

  while (offset < total) {
    const end = Math.min(offset + chunkSize, total);
    const blob = file.slice(offset, end);
    const chunkBuf = new Uint8Array(await blob.arrayBuffer());
    out.set(chunkBuf, offset);
    crc = updateCrc32Streaming(crc, chunkBuf);
    offset = end;
    onProgress(offset, total);
  }
  crc = (crc ^ (-1)) >>> 0;
  return { data: out, crc };
}
async function qcxCreateSingleFileStreaming(file, password, logFn, progCb) {
  logFn("Membaca file secara bertahap (chunk)...");
  const { data } = await readFileAsUint8ArrayStreaming(file, { onProgress: progCb });
  const entry = {
    name: file.name,
    path: file.name,
    type: file.type || "application/octet-stream",
    data
  };
  return await qcxCreateArchiveFromBuffers([entry], password, { logFn });
}

/* ========== UI HELPER ========== */
function formatSize(bytes) {
  if (bytes < 1024) return bytes + " B";
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + " KB";
  if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(2) + " MB";
  return (bytes / (1024 * 1024 * 1024)).toFixed(2) + " GB";
}
function log(el, msg, append = true) {
  if (append) el.textContent += "\n" + msg;
  else el.textContent = msg;
}
function saveUint8AsFile(u8, name) {
  const blob = new Blob([u8]);
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = name;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/* ========== UI ELEMENTS ========== */
const specTextEl = document.getElementById("specText");
specTextEl.textContent = QCX_SPEC_TEXT;

const selfTestLog = document.getElementById("selfTestLog");
const btnRunSelfTest = document.getElementById("btnRunSelfTest");

const singleInput = document.getElementById("singleInput");
const singlePassword = document.getElementById("singlePassword");
const btnSingleCompress = document.getElementById("btnSingleCompress");
const btnSingleDecompress = document.getElementById("btnSingleDecompress");
const logSingle = document.getElementById("log");
const singleProgressText = document.getElementById("singleProgressText");
const singleProgressBar = document.getElementById("singleProgressBar");

const multiInput = document.getElementById("multiInput");
const multiPassword = document.getElementById("multiPassword");
const btnCreateMulti = document.getElementById("btnCreateMulti");
const qcxOpenInput = document.getElementById("qcxOpenInput");
const openPassword = document.getElementById("openPassword");
const btnOpenQcx = document.getElementById("btnOpenQcx");
const btnExtractAll = document.getElementById("btnExtractAll");
const logMulti = document.getElementById("logMulti");
const tableWrap = document.getElementById("tableWrap");
const tableBody = document.getElementById("tableBody");

const kdfModeInfo = document.getElementById("kdfModeInfo");
const kdfRadios = document.querySelectorAll('input[name="kdfMode"]');

kdfRadios.forEach(r => {
  r.addEventListener("change", () => {
    const v = document.querySelector('input[name="kdfMode"]:checked').value;
    currentKdfMode = v;
    kdfModeInfo.textContent =
      "Mode aktif: " + (v === "argon2id" ? "Argon2id (~64MB √ó 3)" : "PBKDF2 (400k iter)");
  });
});

let currentInnerHeader = null;
let currentDataConcat = null;

/* ========== UI: SINGLE COMPRESS ========== */
btnSingleCompress.addEventListener("click", async () => {
  const file = singleInput.files && singleInput.files[0];
  if (!file) { alert("Pilih file dulu untuk dikompres."); return; }
  const pwd = singlePassword.value || "";
  if (pwd.length < 6) { alert("Password minimal 6 karakter."); return; }

  singleProgressText.textContent = "Membaca file...";
  singleProgressBar.style.width = "0%";

  try {
    log(logSingle, "Membuat QCX v3.1 SS (single file, chunked) untuk: " + file.name, false);
    log(logSingle, "KDF: " + (currentKdfMode === "argon2id" ? "Argon2id (~64MB √ó 3)" : "PBKDF2 (400k iter)"), true);
    const { qcxBytes, innerHeader } = await qcxCreateSingleFileStreaming(
      file,
      pwd,
      (m) => log(logSingle, m, true),
      (done, total) => {
        const pct = total ? (done / total) * 100 : 0;
        singleProgressBar.style.width = pct.toFixed(1) + "%";
        singleProgressText.textContent =
          `Membaca file: ${formatSize(done)} / ${formatSize(total)} (${pct.toFixed(1)}%)`;
      }
    );
    const suggested = file.name + ".qcx";
    saveUint8AsFile(qcxBytes, suggested);
    const ratio = 100 * (1 - qcxBytes.length / (innerHeader.totalSize || qcxBytes.length));
    log(logSingle, `Selesai. QCX: ${suggested}`, true);
    log(logSingle, `Rasio kompresi (perkiraan): ${ratio.toFixed(1)}%`, true);
    singleProgressText.textContent = "Selesai";
  } catch (err) {
    console.error(err);
    log(logSingle, "ERROR: " + err.message, true);
    singleProgressText.textContent = "Error";
    alert("Gagal membuat QCX: " + err.message);
  }
});

/* ========== UI: SINGLE DECOMPRESS ========== */
btnSingleDecompress.addEventListener("click", async () => {
  const file = singleInput.files && singleInput.files[0];
  if (!file) { alert("Pilih file .qcx yang akan diekstrak."); return; }
  const pwd = singlePassword.value || "";
  if (!pwd) { alert("Masukkan password QCX."); return; }

  singleProgressText.textContent = "Membaca QCX...";
  singleProgressBar.style.width = "0%";

  try {
    log(logSingle, "Membuka QCX v3.1 SS...", false);
    const buf = new Uint8Array(await file.arrayBuffer());
    singleProgressBar.style.width = "20%";

    const { innerHeader, dataConcat } = await qcxOpenArchive(buf, pwd);
    singleProgressBar.style.width = "80%";

    if (innerHeader.fileCount === 1) {
      const f = innerHeader.files[0];
      const slice = dataConcat.slice(f.offset, f.offset + f.length);
      const safeName = f.path.replace(/[/\\]+/g, "_");
      saveUint8AsFile(slice, safeName);
      log(logSingle, "Diekstrak: " + f.path, true);
    } else {
      log(logSingle, "Arsip multi file. Gunakan panel kanan (Mode Multi) untuk melihat dan ekstrak.", true);
      alert("QCX ini berisi banyak file. Buka di panel 'Mode Multi File / Folder'.");
    }
    singleProgressBar.style.width = "100%";
    singleProgressText.textContent = "Selesai";
  } catch (err) {
    console.error(err);
    log(logSingle, "ERROR: " + err.message, true);
    singleProgressText.textContent = "Error";
    alert("Gagal ekstrak QCX: " + err.message);
  }
});

/* ========== UI: MULTI CREATE ========== */
btnCreateMulti.addEventListener("click", async () => {
  const files = Array.from(multiInput.files || []);
  if (!files.length) { alert("Pilih minimal satu file/folder untuk QCX multi."); return; }
  const pwd = multiPassword.value || "";
  if (pwd.length < 6) { alert("Password minimal 6 karakter."); return; }

  try {
    log(logMulti, `Membuat QCX multi dari ${files.length} file...`, false);
    log(logMulti, "KDF: " + (currentKdfMode === "argon2id" ? "Argon2id (~64MB √ó 3)" : "PBKDF2 (400k iter)"), true);

    const entries = await Promise.all(
      files.map(async f => {
        const path = f.webkitRelativePath && f.webkitRelativePath !== "" ? f.webkitRelativePath : f.name;
        const data = new Uint8Array(await f.arrayBuffer());
        return { name: f.name, path, type: f.type || "application/octet-stream", data };
      })
    );
    const { qcxBytes, innerHeader } = await qcxCreateArchiveFromBuffers(entries, pwd, {
      logFn: (m) => log(logMulti, m, true)
    });
    const suggested = `multi-${Date.now()}.qcx`;
    saveUint8AsFile(qcxBytes, suggested);
    const ratio = 100 * (1 - qcxBytes.length / (innerHeader.totalSize || qcxBytes.length));
    log(logMulti, `QCX multi siap: ${suggested}`, true);
    log(logMulti, `Total ukuran asli: ${formatSize(innerHeader.totalSize)}`, true);
    log(logMulti, `Rasio kompresi (perkiraan): ${ratio.toFixed(1)}%`, true);
  } catch (err) {
    console.error(err);
    log(logMulti, "ERROR: " + err.message, true);
    alert("Gagal membuat QCX multi: " + err.message);
  }
});

/* ========== UI: MULTI OPEN & EXTRACT ========== */
btnOpenQcx.addEventListener("click", async () => {
  const file = qcxOpenInput.files && qcxOpenInput.files[0];
  if (!file) { alert("Pilih QCX yang akan dibuka."); return; }
  const pwd = openPassword.value || "";
  if (!pwd) { alert("Masukkan password QCX."); return; }

  try {
    log(logMulti, "Membuka QCX v3.1 SS...", false);
    const buf = new Uint8Array(await file.arrayBuffer());
    const { innerHeader, dataConcat } = await qcxOpenArchive(buf, pwd);
    currentInnerHeader = innerHeader;
    currentDataConcat = dataConcat;

    log(logMulti, `QCX valid. Jumlah file: ${innerHeader.fileCount}`, true);
    log(logMulti, `Total ukuran asli: ${formatSize(innerHeader.totalSize)}`, true);

    tableBody.innerHTML = "";
    innerHeader.files.forEach((f, idx) => {
      const tr = document.createElement("tr");

      const tdPath = document.createElement("td");
      tdPath.className = "cell-path";
      tdPath.textContent = f.path;

      const tdSize = document.createElement("td");
      tdSize.textContent = formatSize(f.size);

      const tdCrc = document.createElement("td");
      tdCrc.textContent = f.crc32 || "";

      const tdAct = document.createElement("td");
      const btn = document.createElement("button");
      btn.textContent = "Ekstrak";
      btn.className = "btn-sec";
      btn.dataset.index = idx;
      tdAct.appendChild(btn);

      tr.appendChild(tdPath);
      tr.appendChild(tdSize);
      tr.appendChild(tdCrc);
      tr.appendChild(tdAct);
      tableBody.appendChild(tr);
    });

    tableWrap.style.display = "block";
    log(logMulti, "Klik 'Ekstrak' di baris tertentu atau 'Ekstrak Semua ‚Üí Download'.", true);
  } catch (err) {
    console.error(err);
    currentInnerHeader = null;
    currentDataConcat = null;
    tableWrap.style.display = "none";
    log(logMulti, "ERROR: " + err.message, true);
    alert("Gagal membuka QCX: " + err.message);
  }
});

tableBody.addEventListener("click", (e) => {
  const btn = e.target.closest("button");
  if (!btn || btn.dataset.index === undefined) return;
  const idx = parseInt(btn.dataset.index, 10);
  if (!currentInnerHeader || !currentDataConcat) {
    alert("Belum ada QCX yang dibuka.");
    return;
  }
  const f = currentInnerHeader.files[idx];
  const slice = currentDataConcat.slice(f.offset, f.offset + f.length);
  const safeName = f.path.replace(/[/\\]+/g, "_");
  saveUint8AsFile(slice, safeName);
  log(logMulti, "Diekstrak: " + f.path, true);
});

btnExtractAll.addEventListener("click", () => {
  if (!currentInnerHeader || !currentDataConcat) {
    alert("Buka QCX dulu (dengan password yang benar).");
    return;
  }
  const hdr = currentInnerHeader;
  const data = currentDataConcat;
  log(logMulti, "Ekstrak semua file (auto-download)...", true);

  hdr.files.forEach(f => {
    const slice = data.slice(f.offset, f.offset + f.length);
    const safeName = f.path.replace(/[/\\]+/g, "_");
    saveUint8AsFile(slice, safeName);
  });

  log(logMulti, "Selesai. Semua file sudah di-download (nama file menyimpan path asal).", true);
});

/* ========== SELF-TEST & MINI-FUZZ ========== */
async function runSelfTests() {
  selfTestLog.textContent = "Menjalankan self-test QCX v3.1...\n";
  selfTestLog.textContent += "Mode KDF saat test: " +
    (currentKdfMode === "argon2id" ? "Argon2id (~64MB √ó 3)" : "PBKDF2 (400k iter)") + "\n";

  try {
    const password = "test123456";

    // Test 1: round-trip 1 file kecil
    const data1 = textEncoder.encode("Hello QCX!\n");
    const entry1 = { name: "hello.txt", path: "hello.txt", type: "text/plain", data: data1 };
    const { qcxBytes, innerHeader } = await qcxCreateArchiveFromBuffers([entry1], password);
    selfTestLog.textContent += `Self-test 1: QCX dibuat (size=${qcxBytes.length} B, fileCount=${innerHeader.fileCount})\n`;

    const { innerHeader: ih2, dataConcat } = await qcxOpenArchive(qcxBytes, password);
    if (ih2.fileCount !== 1 || ih2.files[0].path !== "hello.txt") {
      throw new Error("Self-test 1 gagal: header tidak cocok");
    }
    const f = ih2.files[0];
    const out1 = dataConcat.slice(f.offset, f.offset + f.length);
    let same = out1.length === data1.length;
    if (same) {
      for (let i = 0; i < out1.length; i++) {
        if (out1[i] !== data1[i]) { same = false; break; }
      }
    }
    if (!same) {
      throw new Error("Self-test 1 gagal: isi file tidak sama");
    }
    selfTestLog.textContent += "Self-test 1: PASS (round-trip 1 file kecil)\n";

    // Test 2: multi file
    const data2a = textEncoder.encode("File A data");
    const data2b = textEncoder.encode("File B data");
    const entries2 = [
      { name: "a.txt", path: "dir/a.txt", type: "text/plain", data: data2a },
      { name: "b.txt", path: "dir/b.txt", type: "text/plain", data: data2b }
    ];
    const { qcxBytes: q2, innerHeader: ihA } = await qcxCreateArchiveFromBuffers(entries2, password);
    const { innerHeader: ihB } = await qcxOpenArchive(q2, password);
    if (ihB.fileCount !== 2) throw new Error("Self-test 2 gagal: fileCount mismatch");
    selfTestLog.textContent += "Self-test 2: PASS (multi file kecil)\n";

    // Mini fuzz: rusak-rusak QCX hasil test 1
    selfTestLog.textContent += "Fuzz: mulai merusak arsip dan memastikan tidak crash...\n";
    for (let i = 0; i < 50; i++) {
      const corrupted = new Uint8Array(qcxBytes);
      const flips = 1 + Math.floor(Math.random() * 8);
      for (let j = 0; j < flips; j++) {
        const idx = Math.floor(Math.random() * corrupted.length);
        corrupted[idx] ^= (1 + Math.floor(Math.random() * 255));
      }
      try {
        await qcxOpenArchive(corrupted, password);
      } catch (e) {
        // error = expected; yang penting tidak crash
      }
    }
    selfTestLog.textContent += "Fuzz: PASS (semua error tertangani, tidak crash)\n";
    selfTestLog.textContent += "Self-test QCX v3.1 selesai tanpa fatal error.\n";
  } catch (err) {
    console.error(err);
    selfTestLog.textContent += "SELF-TEST ERROR: " + err.message + "\n";
  }
}

btnRunSelfTest.addEventListener("click", () => {
  runSelfTests();
});

window.addEventListener("load", () => {
  runSelfTests();
});
</script>
</body>
</html>
